# RFC-006: Compositions (Semantic Entry Grouping)

**Status:** Implemented
**Audience:** Core maintainers, contributors
**Applies to:** Jot v0.2+
**Phase:** 0.2

---

## 1. Purpose

This RFC defines **Compositions** — a first-class grouping primitive that allows entries to be associated with larger conceptual containers (projects, research topics, narratives) without enforcing structural coupling.

Compositions solve a real organizational problem:

> "I want all my `project_x_notes` to belong to `project_x`, but only *some* of my bookmarks."

This is not achievable with tags alone, and should not require creating artificial entry types.

---

## 2. What Compositions Are (And Are Not)

### Compositions ARE:

* Semantic containers for entries
* User-defined, named entities
* Many-to-many relationships (entries ↔ compositions)
* A filter dimension for search and queries
* Orthogonal to entry types

### Compositions are NOT:

* Folders or hierarchies
* Schema namespaces
* Entry types in disguise
* Authorization boundaries
* Deletion cascades

**Invariant:** Compositions are purely associative. They group entries without defining or constraining them.

---

## 3. Mental Model

Think in three orthogonal axes:

```
Entry Type (Schema)  → what kind of data is this?
Entry (Instance)     → a single fact, note, or record
Composition          → what larger thing does this belong to?
```

These axes must never collapse into one another.

---

## 4. Core Concepts

### 4.1 Composition

A **Composition** is a named entity representing a conceptual grouping.

Examples:

* `project_x`
* `thesis_research`
* `health_journey_2025`
* `book_notes_dune`
* `investigation_case_17`

Properties:

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Globally unique identifier |
| `name` | string | User-facing name (unique within jot) |
| `description` | string? | Optional description |
| `created_at` | datetime | When created |
| `device_id` | UUID | Device that created this composition |
| `metadata_json` | JSON? | Optional structured metadata |

### 4.2 Entry–Composition Relationship

The relationship between entries and compositions is **many-to-many**.

| Relationship | Cardinality | Notes |
|--------------|-------------|-------|
| Entry → Composition | 0..N | Entry can belong to many compositions |
| Composition → Entry | 0..N | Composition can contain many entries |
| Entry Type → Composition | 0..1 | Optional default (see §5) |

### 4.3 Key Behaviors

* Removing a composition does **not** delete its entries
* Removing an entry does **not** delete the composition
* Associations can be added/removed at any time
* No ordering of entries within compositions (use timestamps)

---

## 5. Entry Type Defaults (Optional)

Entry types can specify a **default composition**:

```json
{
  "name": "project_x_notes",
  "version": 1,
  "default_composition_id": "3b0c9b72-3a9d-4ad6-8a70-2c52a6622f3a",
  "fields": [...]
}
```

Behavior:

* When creating an entry of this type, Jot auto-associates it with the default composition
* User can override with `--compose` or `--no-compose` flags
* Default is a convenience, not a constraint

This enables your pattern:

> "All `project_x_notes` should fall under `project_x` by default."

---

### 5.1 Templates + Compositions

Templates can specify default compositions and act as reusable entry presets:

* Templates live in the jot and can be shared across machines.
* A template can set `default_compositions` (composition IDs) to auto-attach entries.
* Composition-scoped templates are allowed (e.g., `gas_fillup` within `fleet_ops`).

When both an entry type default and a template default are present:

* Template defaults win unless overridden by `--compose`.
* `--no-compose` clears both.

---

## 6. Data Model

### 6.1 Compositions Table

```sql
CREATE TABLE compositions (
    id TEXT PRIMARY KEY,           -- UUID
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    created_at TEXT NOT NULL,      -- ISO-8601
    device_id TEXT NOT NULL,       -- UUID
    metadata_json TEXT
);
```

### 6.2 Entry–Composition Join Table

```sql
CREATE TABLE entry_compositions (
    entry_id TEXT NOT NULL,        -- UUID
    composition_id TEXT NOT NULL,  -- UUID
    added_at TEXT NOT NULL,        -- ISO-8601

    PRIMARY KEY (entry_id, composition_id),
    FOREIGN KEY (entry_id) REFERENCES entries(id),
    FOREIGN KEY (composition_id) REFERENCES compositions(id)
);
```

### 6.3 Entry Type Default (Optional Field)

In `entry_type_versions.schema_json`:

```json
{
  "default_composition_id": "3b0c9b72-3a9d-4ad6-8a70-2c52a6622f3a"
}
```

This is stored as a composition ID reference, resolved at entry creation time.

---

## 7. CLI Commands

### 7.1 Composition Management

```bash
# Create a composition
jot compositions create project_x
jot compositions create thesis_research --description "PhD work"

# List compositions
jot compositions
jot compositions list

# Show composition details
jot compositions show project_x

# Rename composition
jot compositions rename project_x project_alpha

# Delete composition (does not delete entries)
jot compositions delete old_project --confirm
```

### 7.2 Entry Creation with Composition

```bash
# Add entry to specific composition
jot add bookmark --url https://example.com --compose project_x

# Add entry to multiple compositions
jot add journal --compose thesis_research --compose health_journey

# Override default composition
jot add project_x_notes --compose different_project

# Skip default composition
jot add project_x_notes --no-compose
```

### 7.3 Associating Existing Entries

```bash
# Attach entry to composition
jot attach <entry-id> project_x

# Attach multiple entries
jot attach <id1> <id2> <id3> project_x

# Detach entry from composition
jot detach <entry-id> project_x
```

### 7.4 Filtering by Composition

```bash
# List all entries in a composition
jot list --compose project_x

# List specific type within composition
jot list bookmark --compose project_x

# Search within composition
jot search "vector clocks" --compose thesis_research

# Export composition
jot export --compose project_x --json
```

---

## 8. Distinction From Tags

Both tags and compositions provide grouping, but they serve different purposes:

| Aspect | Tags | Compositions |
|--------|------|--------------|
| Quantity | Many, lightweight | Few, heavyweight |
| Creation | Implicit (on entry) | Explicit (separate step) |
| Semantics | Attributes, labels | Narratives, projects |
| Typical use | `#daily`, `#important` | `thesis_research`, `project_x` |
| Noise tolerance | High | Low |

**You want both.** Tags for quick labeling, compositions for meaningful grouping.

---

## 9. Search & Query Integration

Compositions become a first-class filter dimension:

```bash
# Filter by composition
jot list --compose project_x
jot search "important" --compose thesis_research

# Combine with other filters
jot list todo --compose project_x --tag urgent --last 30d

# Future: query expressions
jot list --where "compose = project_x AND completed = false"
```

---

## 10. Why Not Folders or Hierarchies?

Compositions are explicitly **flat** and **non-exclusive**:

* Entries can belong to multiple compositions
* No tree structure to manage
* No forced nesting
* No migration pain when ideas evolve

This mirrors how research and thinking actually work. A note about "distributed systems" might belong to both `thesis_research` and `work_project` simultaneously.

---

## 11. Edge Cases

### 11.1 Deleted Composition

When a composition is deleted:

* All entry associations are removed
* Entries themselves are unchanged
* Warning shown if composition has entries

### 11.2 Orphaned Default

If an entry type's `default_composition_id` references a deleted composition:

* Warning on entry creation
* Entry created without composition
* `jot check` reports the orphan

### 11.3 Circular Defaults

Not possible — compositions don't have schemas, entry types don't nest.

---

## 12. Phase Rollout

| Feature | Phase 0.1 | Phase 0.2 | Phase 1.0 |
|---------|-----------|-----------|-----------|
| Compositions table | No | Yes | Yes |
| `--compose` flag | No | Yes | Yes |
| Entry type defaults | No | Yes | Yes |
| `jot attach/detach` | No | Yes | Yes |
| Filter by composition | No | Yes | Yes |
| Composition metadata | No | Basic | Full |

---

## 13. Design Constraints

* Compositions live **inside the encrypted jot**
* Composition names are unique (within jot)
* All composition operations go through storage abstraction
* No external dependencies on compositions
* Compositions do not affect encryption or key management

---

## 14. Format Spec Impact

When `docs/design/format-spec.md` is created, include:

* Compositions entity definition
* Entry–composition relationship schema
* Statement: "Compositions are associative metadata, not structural schema"
* Version note: "Introduced in format v0.2"
* Template defaults that reference compositions by ID

---

## 15. Why This Design Works

This model:

* Solves a real organizational problem
* Avoids schema explosion (no `project_x_notes` type needed)
* Scales from journaling to research
* Stays orthogonal to entry types
* Differentiates Jot from simpler tools
* Preserves append-only semantics (associations are entries too)

Most importantly:

> **Compositions are additive, not invasive.** They don't change how entries or schemas work — they add a new dimension of organization.

---

## 16. Open Questions

* Should compositions support nesting (sub-compositions)? → Probably not for v0.2
* Should compositions have a "status" (active/archived)? → Maybe v1.0
* Should compositions support custom fields? → Deferred to `metadata_json`
