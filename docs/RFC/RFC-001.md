# RFC-001: Storage & Encryption Model

**Status:** Draft (Revised)
**Audience:** Core maintainers, contributors
**Applies to:** Ledger v0.1+

---

## 1. Goals

**Must-have**

* **One logical ledger** — users think of their data as a single thing
* **Encryption at rest by default** — no plaintext mode
* **Fast tags/search/query** — including full-text
* **Structured entries** (JSON-ish) with schema evolution
* **Cross-platform** — macOS/Linux first, Windows not blocked
* **Simple build story** — installable without dependency hell

**Nice-to-have**

* Key rotation
* Git-friendly storage format
* Multiple storage backends

---

## 2. Threat Model

### We defend against:

* Theft of the jot file (GitHub repo, backup, laptop disk image)
* Access to the file while the application is closed
* Offline brute-force attacks on the passphrase

### We do NOT primarily defend against:

* An attacker with access to your unlocked session / memory
* A malicious OS / keylogger while you type your passphrase
* Compromised build chain (mitigated later via releases + signatures)

### Core requirement:

> If someone steals the file, they learn **nothing** without the key.

---

## 3. Storage Abstraction (Critical Decision)

Ledger defines a **Storage Engine interface** rather than hardcoding a single backend.

### Why abstract early?

1. **Build complexity varies by backend** — SQLCipher is powerful but painful to build; GPG is ubiquitous but slower
2. **Tradeoffs differ by use case** — single-file portability vs. git-friendly diffs
3. **Derisks the project** — if one backend proves problematic, we can switch without redesigning everything
4. **Enables experimentation** — Phase 0.1 can use a simpler backend while we validate UX

### Storage Engine Interface (Conceptual)

```rust
trait StorageEngine {
    fn open(path: &Path, key: &DerivedKey) -> Result<Self>;
    fn close(&mut self) -> Result<()>;

    // Entry operations
    fn insert_entry(&mut self, entry: &Entry) -> Result<Uuid>;
    fn get_entry(&self, id: &Uuid) -> Result<Option<Entry>>;
    fn list_entries(&self, filter: &EntryFilter) -> Result<Vec<Entry>>;

    // Schema operations
    fn get_schema(&self, name: &str) -> Result<Option<Schema>>;
    fn create_schema(&mut self, schema: &Schema) -> Result<()>;

    // Search
    fn search(&self, query: &str) -> Result<Vec<Entry>>;

    // Maintenance
    fn check_integrity(&self) -> Result<IntegrityReport>;
    fn backup(&self, dest: &Path) -> Result<()>;
}
```

This interface is implementation-agnostic. Backends implement the trait.

---

## 4. Backend Options

### Option A: SQLCipher (Encrypted SQLite)

Encrypt the entire database file at the SQLite layer.

**Pros**

* Whole file encrypted at rest
* Minimal custom crypto code
* Queries, indexes, FTS work inside the encrypted DB
* Mature, well-audited

**Cons**

* Build/linking complexity (SQLCipher + OpenSSL/BoringSSL)
* Platform-specific packaging work
* Cross-compilation is painful
* `rusqlite` with sqlcipher feature is fragile on some platforms

**Recommendation:** Good long-term choice, but validate build story before committing.

### Option B: GPG + Individual Files

Store entries as individual GPG-encrypted JSON files with a plaintext index.

```
ledger/
├── index.db           # plaintext SQLite (rebuilt on unlock)
├── entries/
│   ├── 2026-01-07-abc123.json.gpg
│   └── ...
└── schemas/
    └── journal-v1.json.gpg
```

**Pros**

* GPG is ubiquitous, no build complexity
* Git diffs work at the file level
* Partial corruption doesn't destroy everything
* Proven encryption

**Cons**

* Two sources of truth (encrypted entries vs index)
* Index rebuild on unlock
* Slower queries (must decrypt to search without index)
* More complex transactional guarantees

**Recommendation:** Good for Phase 0.1 prototyping. Simpler build, but more application complexity.

### Option C: Age + SQLite

Use the `age` encryption tool (simpler than GPG) to encrypt a standard SQLite database.

**Pros**

* `age` is modern, simple, well-designed
* Standard SQLite tooling works on the decrypted DB
* Simpler than SQLCipher build story

**Cons**

* Requires decrypt-to-temp-file workflow
* Temp file security concerns
* Not as mature as GPG

**Recommendation:** Worth considering for Phase 0.1.

### Option D: Pure Rust Encryption + SQLite

Use a Rust-native encryption library (e.g., `chacha20poly1305`) to encrypt a SQLite database file.

**Pros**

* No C dependencies
* Cross-platform builds are trivial
* Full control over encryption

**Cons**

* More custom code to audit
* Must handle streaming encryption carefully
* Less mature than SQLCipher

**Recommendation:** Consider for long-term if SQLCipher build story is untenable.

---

## 5. Phase 0.1 Storage Backend (Locked Decision)

**Decision:** Ledger Phase 0.1 uses **Age-encrypted SQLite** as its storage backend.

This decision is **locked** for Phase 0.1. It may be revisited for Phase 1.0 based on learnings.

### 5.1 Why Age + SQLite

| Factor | Age + SQLite | SQLCipher | GPG + Files |
|--------|--------------|-----------|-------------|
| Build complexity | Low (pure Rust) | High (C deps) | Low |
| Cross-compilation | Easy | Painful | Easy |
| Query capability | Full SQL + FTS5 | Full SQL + FTS5 | Rebuild index |
| Single-file semantics | Yes | Yes | Directory |
| Ecosystem maturity | Good | Excellent | Excellent |
| Temp file risk | Manageable | None | None |

**Age + SQLite wins for Phase 0.1 because:**

1. **No C toolchain dependencies** — `age` crate is pure Rust
2. **SQLite gives us FTS5** — real full-text search without inventing a query engine
3. **Clean CI** — builds on Linux/macOS without special setup
4. **Escape hatch preserved** — can migrate to SQLCipher later via storage abstraction

### 5.2 Why SQLCipher Is Deferred (Not Rejected)

SQLCipher remains the likely Phase 1.0 choice because:

* No temp file concerns
* Battle-tested in production
* Single conceptual model

**Criteria for switching to SQLCipher:**

1. Phase 0.1 validates UX and data model
2. SQLCipher build story tested on all target platforms
3. Migration tooling exists to convert Age+SQLite → SQLCipher
4. No showstopper issues discovered in Phase 0.1

### 5.3 What This Decision Enables

With Age + SQLite locked:

* CLI semantics can be finalized
* Error handling can be designed concretely
* Format spec can describe real artifacts
* Milestone 0→1 commits can proceed

---

## 6. Encrypt/Decrypt Lifecycle (Age + SQLite)

This section defines the exact behavior of the Phase 0.1 backend.

### 6.1 File Format

A Ledger file (`.jot`) is an Age-encrypted SQLite database:

```
my.jot = age_encrypt(passphrase, sqlite_database_bytes)
```

The file is a single opaque blob. There is no unencrypted header in Phase 0.1.

### 6.2 Open Lifecycle

When user runs `jot open my.jot` (or any command requiring data):

```
1. Check file exists
2. Prompt for passphrase (unless cached/provided)
3. Derive key: passphrase → Argon2id → age identity
4. Decrypt: age_decrypt(file) → plaintext SQLite bytes
5. Load SQLite:
   - PRIMARY: In-memory (`:memory:` with deserialize)
   - FALLBACK: Secure temp file (see §7)
6. Validate: Check schema version, run integrity check
7. Ready for operations
```

### 6.3 Operation Lifecycle

While ledger is open:

```
- All reads/writes go to in-memory SQLite
- No writes to disk until close
- Session may be long-lived (interactive) or short (single command)
```

### 6.4 Close Lifecycle

On clean shutdown:

```
1. Finalize any pending transactions
2. Serialize SQLite database to bytes
3. Re-encrypt: age_encrypt(bytes) → ciphertext
4. Atomic write: Write to temp file, rename to target
5. Wipe plaintext:
   - If in-memory: Let Rust drop handle
   - If temp file: Overwrite with zeros, then delete
6. Clear derived key from memory
```

### 6.5 Crash Handling

If Ledger crashes or is killed:

```
- In-memory mode: All uncommitted changes lost (acceptable)
- Temp file mode: Plaintext may persist on disk (see §7 mitigations)
- Original encrypted file: Unchanged (safe)
```

**Guarantee:** A crash never corrupts the encrypted file. At worst, recent changes are lost.

### 6.6 Session Modes

Ledger supports two session modes:

**Transient (default for single commands):**
```bash
jot add journal    # Opens, adds, closes
jot list           # Opens, lists, closes
```

**Persistent (for interactive use, Phase 0.2+):**
```bash
ledger open my.jot  # Opens, stays open
jot add journal     # Uses open session
ledger close           # Explicitly closes
```

Phase 0.1 uses transient mode only. Each command is a full open→operate→close cycle.

---

## 7. Temp File Security Strategy

This section is explicit about risks and mitigations. No hand-waving.

### 7.1 Primary Strategy: In-Memory SQLite

SQLite supports loading a database entirely in memory:

```rust
// Pseudocode
let db_bytes = age_decrypt(&file_contents, &key)?;
let conn = Connection::open_in_memory()?;
conn.deserialize(&db_bytes)?;
```

**Properties:**

* No plaintext touches disk
* Fast for personal-scale data (< 100MB typical)
* Survives most threat model scenarios

**Limitations:**

* Requires SQLite `deserialize` support (available in modern SQLite)
* Memory pressure on large ledgers
* Swap could theoretically contain plaintext (OS-level concern)

### 7.2 Fallback Strategy: Secure Temp File

If in-memory fails (large ledger, old SQLite):

```rust
// Pseudocode
let temp_path = secure_temp_file()?;  // Random name, 0600 perms
write(&temp_path, &decrypted_bytes)?;
let conn = Connection::open(&temp_path)?;
// ... operations ...
conn.close()?;
secure_delete(&temp_path)?;  // Overwrite then unlink
```

**Mitigations applied:**

| Risk | Mitigation |
|------|------------|
| Other users read file | Mode 0600, user-only temp dir |
| Filename guessable | Random 128-bit filename |
| Data persists after close | Overwrite with zeros before unlink |
| Crash leaves file | Document in threat model |

### 7.3 Secure Delete Implementation

```rust
fn secure_delete(path: &Path) -> Result<()> {
    let file = File::open(path)?;
    let len = file.metadata()?.len();

    // Overwrite with zeros
    file.set_len(0)?;
    file.set_len(len)?;
    file.write_all(&vec![0u8; len as usize])?;
    file.sync_all()?;

    // Then unlink
    std::fs::remove_file(path)?;
    Ok(())
}
```

**Note:** This is not forensic-grade secure deletion (SSDs, journaling filesystems, etc.). The threat model explicitly excludes disk forensics.

### 7.4 Known Limitations (Documented, Not Hidden)

| Scenario | Risk | Mitigation |
|----------|------|------------|
| OS crash during operation | Temp file persists | User should use encrypted disk |
| Swap contains plaintext | Theoretical leak | Out of scope (OS-level) |
| Filesystem journaling | Partial writes may persist | Accepted risk |
| SSD wear leveling | Old data may exist | Accepted risk |

**Our position:** These are OS-level concerns. Ledger's threat model targets file theft, not live system forensics. Users with higher security requirements should use full-disk encryption.

### 7.5 Configuration

Users can influence temp file behavior:

```toml
# ~/.config/ledger/config.toml
[storage]
# Force in-memory only (fail if too large)
force_memory = false

# Custom temp directory (e.g., encrypted ramdisk)
temp_dir = "/run/user/1000/ledger"
```

---

## 8. Key Management Model

Regardless of backend, key management is consistent.

### Unlocking

Ledger is unlocked with:

* **Passphrase** (default)
* Optional **keyfile** (advanced mode)
* Optional OS keychain integration (future)

### Key Derivation (KDF)

Passphrase → encryption key using a strong KDF.

**Recommended KDF:** `Argon2id`

* Memory-hard, modern default
* Parameters stored in ledger metadata

**Default parameters (initial)**

* `m = 64–256 MB` (tunable)
* `t = 2–4 iterations`
* `p = 1`

Provide a `jot doctor` command to benchmark and recommend settings.

### Salt

* Random 16+ bytes per ledger
* Stored in ledger metadata (not secret)

---

## 9. Logical File Format

Regardless of backend, the user interacts with "a jot" as one thing.

### What the user sees

```bash
ledger open ~/journals/personal.jot
ledger open ~/journals/work.jot
```

### What's on disk

Implementation-dependent:

* **Single file:** `personal.jot` (SQLCipher or age-encrypted SQLite)
* **Directory:** `personal.jot/` (GPG + files)
* **Archive:** `personal.jot.tar.age` (encrypted tarball)

The abstraction hides this. Commands like `backup`, `export`, and `check` work regardless.

---

## 10. Preventing Data Leaks

### For SQLCipher backend

Configure pragmas to prevent plaintext artifacts:

* `PRAGMA cipher_memory_security = ON;`
* `PRAGMA temp_store = MEMORY;`
* `PRAGMA secure_delete = ON;`
* `PRAGMA journal_mode = WAL;` (only if WAL is encrypted)

### For GPG/Age backends

* Never write plaintext to disk
* Decrypt to memory, not temp files
* If temp files are unavoidable, use secure deletion

### General

* `jot doctor` checks for common security misconfigurations
* Document exact behavior per platform

---

## 11. Integrity & Tamper Detection

Encryption alone doesn't guarantee "this file wasn't tampered with."

### For SQLCipher

* Authenticated encryption for pages (integrity checks built-in)
* Random modification breaks decryption / yields corruption

### For all backends

* Store `meta.last_clean_shutdown`
* Store `meta.schema_hash`
* `jot check` runs integrity verification

---

## 12. Git & Sync Strategy

### Reality check

A single encrypted blob is **perfect for confidentiality** but **not great for Git diffs/merges**.

* Git treats it as a binary blob
* Conflicts are hard to merge

### Our position

* "Git as backup/versioning" is supported and encouraged
* "Git as collaborative merge" is not a goal
* Multi-device use requires conflict-aware data model (see RFC-004)

### Mitigations

* Encourage single-writer workflow or frequent pulls
* Provide `jot export --since <rev>` for mergeable patch format (future)
* UUID-based entries make eventual conflict resolution possible

---

## 13. Backups & Recovery

Because corruption is catastrophic:

### Planned commands

* `jot check` — runs integrity check
* `jot backup` — copies ledger + optional verify
* `jot vacuum` — compacts (where applicable)
* `jot export` — JSONL export for external backups

### Recommendation

Encourage regular `jot backup` and Git commits. Document recovery procedures.

---

## 14. Key Rotation (v1.0+)

Future feature:

* Re-encrypt with new key
* Multiple key slots (passphrase A + passphrase B)
* Support passphrase change

For SQLCipher: `PRAGMA rekey = 'newkey';`
For Age: Re-encrypt entire database with new key

Not required for Phase 0.1 but planned.

---

## 15. Summary of Decisions

| Decision | Phase 0.1 | Phase 1.0+ |
|----------|-----------|------------|
| Storage abstraction | Required | Required |
| Backend | **Age + SQLite (locked)** | SQLCipher (likely) |
| KDF | Argon2id | Argon2id |
| Key management | Passphrase only | Passphrase + keyfile + keychain |
| Git strategy | Backup/versioning | Backup/versioning |
| Key rotation | Deferred | Supported |
| Session mode | Transient only | Persistent available |

---

## 16. Open Questions

* Should we support multiple backends long-term, or converge on SQLCipher?
* How do we handle backend migration (Age+SQLite → SQLCipher)?
* What's the maximum ledger size before in-memory SQLite becomes problematic?

---

## 17. Next Steps

1. ~~Choose Phase 0.1 backend~~ ✓ Age + SQLite locked
2. Draft format-spec skeleton (Option B)
3. Implement storage abstraction trait
4. Build Milestone 0 skeleton
5. Validate in-memory SQLite deserialize on target platforms
6. Build SQLCipher backend in isolation for Phase 1.0 evaluation
