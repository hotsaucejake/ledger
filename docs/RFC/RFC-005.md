# RFC-005: Repository & Implementation Plan

**Status:** Draft (Revised)
**Audience:** Core maintainers, contributors
**Applies to:** Ledger v0.1+

---

## 1. Goals of This Phase

This planning phase exists to ensure:

* Clear separation of concerns
* A codebase that invites contribution
* Minimal rewrites as features grow
* A stable core with flexible edges
* Incremental, testable milestones
* **Validation of risky assumptions early**

We are explicitly optimizing for:

> **Risk reduction and long-term maintainability over speed**

---

## 2. Repository Layout

Ledger is a **Rust workspace** producing a single CLI binary (with optional migration tool).

### Proposed Structure

```
ledger/
├── Cargo.toml              # Workspace root
├── Cargo.lock
├── README.md
├── LICENSE
├── docs/
│   ├── rfcs/
│   │   ├── RFC-001-storage.md
│   │   ├── RFC-002-schemas.md
│   │   ├── RFC-003-cli.md
│   │   ├── RFC-004-data-model.md
│   │   └── RFC-005-implementation.md
│   ├── design/
│   │   ├── threat-model.md
│   │   └── format-spec.md      # REQUIRED before v1
│   └── user/
│       └── getting-started.md
├── crates/
│   ├── jot-core/
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── storage/         # Storage abstraction
│   │       │   ├── mod.rs
│   │       │   ├── trait.rs     # StorageEngine trait
│   │       │   ├── sqlite.rs    # SQLite backend
│   │       │   └── gpg.rs       # GPG+files backend (future)
│   │       ├── crypto/
│   │       ├── schema/
│   │       ├── entry/
│   │       ├── search/
│   │       ├── tags/
│   │       ├── export/
│   │       ├── error.rs
│   │       └── prelude.rs
│   ├── jot-cli/
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── main.rs
│   │       ├── commands/
│   │       ├── prompts/
│   │       ├── output/
│   │       └── args.rs
│   └── ledger-migrate/         # Deferred to Phase 1.0
│       └── ...
└── tests/
    └── integration/
```

---

## 3. Crate Responsibilities

### 3.1 `jot-core` (The Heart)

**Rules**

* No CLI code
* No user interaction
* No printing
* Deterministic, testable APIs
* **Storage-backend agnostic**

**Responsibilities**

* Storage abstraction (`StorageEngine` trait)
* Encryption & key handling
* Entry schemas and validation
* Entry creation
* Search & tagging
* Export logic
* Domain-level errors

This crate should feel like a **library**, not an app.

### 3.2 `jot-cli` (Human Interface)

**Responsibilities**

* Clap command parsing
* Interactive prompts (via `dialoguer` or similar)
* `$EDITOR` integration
* Human-readable output
* Progress and confirmations

**Rules**

* No SQL
* No encryption logic
* No schema validation rules
* Everything goes through `jot-core`

This keeps UX flexible without risking data integrity.

### 3.3 `ledger-migrate` (Phase 1.0+)

A separate binary for:

* DB migrations
* Repair
* Schema introspection
* Backend conversion

This avoids bloating the main CLI and gives power tools to advanced users.

---

## 4. Storage Abstraction (Critical)

### 4.1 The `StorageEngine` Trait

```rust
pub trait StorageEngine: Send + Sync {
    // Lifecycle
    fn open(path: &Path, key: &DerivedKey) -> Result<Self> where Self: Sized;
    fn close(&mut self) -> Result<()>;
    fn is_locked(&self) -> bool;

    // Entries
    fn insert_entry(&mut self, entry: &NewEntry) -> Result<Uuid>;
    fn get_entry(&self, id: &Uuid) -> Result<Option<Entry>>;
    fn list_entries(&self, filter: &EntryFilter) -> Result<Vec<Entry>>;
    fn search_entries(&self, query: &str) -> Result<Vec<Entry>>;

    // Schemas
    fn get_entry_type(&self, name: &str) -> Result<Option<EntryType>>;
    fn create_entry_type(&mut self, entry_type: &NewEntryType) -> Result<Uuid>;
    fn list_entry_types(&self) -> Result<Vec<EntryType>>;

    // Maintenance
    fn check_integrity(&self) -> Result<IntegrityReport>;
    fn backup(&self, dest: &Path) -> Result<()>;
}
```

### 4.2 Backend Implementations

| Backend | Phase | Status |
|---------|-------|--------|
| SQLite + Age encryption | 0.1 | Primary |
| SQLCipher | 0.2+ | If build story validates |
| GPG + files | Future | If git-friendliness needed |

### 4.3 Why Abstract Now?

* **Derisks SQLCipher** — if build is painful, we can switch
* **Enables testing** — mock backends for fast tests
* **Future flexibility** — different backends for different use cases

---

## 5. Module Boundaries (Inside `jot-core`)

### 5.1 `storage/`

* `StorageEngine` trait definition
* Backend implementations
* Transaction helpers

### 5.2 `crypto/`

* Passphrase handling
* Argon2id key derivation
* Key validation
* (Rekey logic deferred)

### 5.3 `schema/`

* Entry type definitions
* Field validation
* Schema versioning
* Typo detection logic

### 5.4 `entry/`

* Entry creation
* Data validation against schema
* UUID generation
* Device ID handling

### 5.5 `search/`

* FTS document generation
* Query parsing
* Ranking

### 5.6 `tags/`

* Tag normalization
* Filtering

### 5.7 `export/`

* JSON / JSONL exporters
* Future formats (CSV, etc.)

---

## 6. Error Handling

### 6.1 Core Error Type

```rust
#[derive(Debug, thiserror::Error)]
pub enum JotError {
    #[error("Encryption error: {0}")]
    Crypto(String),

    #[error("Schema error: {0}")]
    Schema(String),

    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Storage error: {0}")]
    Storage(String),

    #[error("Not found: {0}")]
    NotFound(String),

    #[error("Invalid input: {0}")]
    InvalidInput(String),
}
```

### 6.2 CLI Error Mapping

CLI maps core errors to:
* Friendly messages
* Hints and suggestions
* Appropriate exit codes

> **Core errors are descriptive. CLI errors are helpful.**

---

## 7. Implementation Milestones

### Milestone 0: Skeleton

**Goal:** Prove the project compiles and structure is sound.

* [ ] Repo created with workspace structure
* [ ] `jot --help` works
* [ ] CI runs (build + clippy + fmt)
* [ ] No real logic yet

**Deliverable:** Empty but working CLI.

### Milestone 1: Encrypted Storage

**Goal:** Validate the encryption story builds and works.

* [ ] Create new ledger with passphrase
* [ ] Open existing ledger
* [ ] Store and retrieve test data
* [ ] Verify encryption at rest
* [ ] Test on macOS and Linux

**Deliverable:** `jot init`, `jot unlock` work.

**Risk validation:** Does the encryption backend build cleanly?

### Milestone 2: Journal Entries

**Goal:** Core journaling works end-to-end.

* [ ] Built-in `journal` entry type
* [ ] `jot add journal` opens $EDITOR
* [ ] `jot list` shows entries
* [ ] `jot show <id>` displays entry
* [ ] Tags work
* [ ] UUIDs and device IDs stored

**Deliverable:** Usable as a basic encrypted journal.

### Milestone 3: Search

**Goal:** Full-text search works.

* [ ] FTS index created and maintained
* [ ] `jot search <query>` returns results
* [ ] Results ranked by relevance
* [ ] Search respects filters

**Deliverable:** Can find old journal entries.

### Milestone 4: Export & Backup

**Goal:** Data can leave the system.

* [ ] `jot export --json`
* [ ] `jot export --jsonl`
* [ ] `jot backup`
* [ ] `jot check`

**Deliverable:** Phase 0.1 complete.

### Milestone 5: User-Defined Schemas (Phase 0.2)

**Goal:** Users can create their own entry types.

* [ ] `jot types create <name>`
* [ ] Interactive field definition
* [ ] Schema validation
* [ ] `jot add <type>` with prompts
* [ ] Typo detection

**Deliverable:** Full schema system.

### Milestone 5b: Compositions (Phase 0.2)

**Goal:** Semantic grouping of entries across types. See RFC-006.

* [ ] `compositions` table
* [ ] `entry_compositions` join table
* [ ] `jot compositions create/list/show`
* [ ] `--compose` flag on `jot add`
* [ ] `jot attach/detach` commands
* [ ] `--compose` filter on list/search

**Deliverable:** Cross-type entry organization.

### Milestone 5c: Templates (Phase 0.2)

**Goal:** Reusable defaults stored inside the jot for cross-device use.

* [ ] `templates` table
* [ ] `template_versions` table
* [ ] `jot templates create/list/show`
* [ ] `jot templates update/delete`
* [ ] `--template` flag on `jot add`
* [ ] Template defaults (fields, tags, compositions)

**Deliverable:** Entry presets and reusable defaults.

### Milestone 6: Advanced Features (Phase 0.3+)

* [ ] `--where` query expressions
* [ ] Entry revisions
* [ ] CSV export
* [ ] Import from other tools

---

## 8. Testing Strategy

### 8.1 Unit Tests (jot-core)

* Schema validation
* Field parsing
* Default application
* Error cases
* UUID generation

### 8.2 Integration Tests

* CLI commands end-to-end
* Temporary encrypted ledgers
* Full user flows

### 8.3 Testing Interactive Prompts

```rust
// Use a PromptProvider trait
pub trait PromptProvider {
    fn prompt_string(&self, message: &str) -> Result<String>;
    fn prompt_confirm(&self, message: &str) -> Result<bool>;
    fn open_editor(&self, content: &str) -> Result<String>;
}

// Real implementation uses dialoguer
// Test implementation returns predetermined values
```

### 8.4 Test Requirements

* Never require user input
* Never rely on global state
* Run deterministically
* Fast (< 100ms per test)

---

## 9. Documentation Requirements

### 9.1 Required Before v1.0

| Document | Purpose |
|----------|---------|
| `docs/design/format-spec.md` | File format specification |
| `docs/design/threat-model.md` | Security assumptions |
| `README.md` | User-facing quickstart |
| Inline Rust docs | API documentation |

### 9.2 Format Specification

The format spec must:
* Be implementation-independent
* Describe exact byte layouts (or JSON schemas)
* Enable third-party tooling
* Be versioned

**This is non-negotiable for the "long-term data" promise.**

### 9.3 RFC Preservation

Design RFCs are **never deleted** — they document *why* decisions were made, even if those decisions later change.

---

## 10. Versioning & Stability

### 10.1 Semantic Versioning

* `0.x.y` — pre-1.0, breaking changes allowed
* `1.x.y` — stable, backward-compatible

### 10.2 Stability Guarantees (v1.0+)

* Database format compatibility
* CLI command syntax
* Export format
* Config file format

Breaking changes require migration tooling.

---

## 11. Contribution Model

### 11.1 Issues

* Must describe the problem
* Include reproduction steps for bugs
* Suggest solution (optional)

### 11.2 Pull Requests

* Must include tests for new behavior
* Must pass CI
* Must update relevant docs

### 11.3 Design Changes

* Require RFC for architectural changes
* RFC must be reviewed before implementation
* Implementation may differ from RFC (with documented rationale)

---

## 12. Build & Release

### 12.1 CI Pipeline

* Build on Linux, macOS
* Run tests
* Run clippy (warnings = errors)
* Check formatting

### 12.2 Release Process

* Tag with semantic version
* Build release binaries
* Generate checksums
* Update changelog

### 12.3 Binary Distribution

| Platform | Format |
|----------|--------|
| macOS | Homebrew tap, .tar.gz |
| Linux | .tar.gz, .deb (future) |
| Windows | .zip (future) |

---

## 13. Risk Mitigation

### 13.1 Identified Risks

| Risk | Mitigation |
|------|------------|
| SQLCipher build complexity | Storage abstraction, start with simpler backend |
| Scope creep | Phased milestones, defer non-essentials |
| Data loss | Append-only model, backups, integrity checks |
| Poor UX | Early dogfooding, prompt testing |

### 13.2 Validation Points

After each milestone, ask:
* Does the build story work?
* Is the UX acceptable?
* Are there showstopper bugs?
* Should we continue or pivot?

---

## 14. Phase Summary

| Phase | Focus | Milestone |
|-------|-------|-----------|
| 0.1 | Core journal + encryption | M0-M4 |
| 0.2 | User-defined schemas | M5 |
| 0.3 | Query expressions, polish | M6 |
| 1.0 | Stability, format spec, migration | - |

---

## 15. Success Criteria

### Phase 0.1 is successful if:

* [ ] Ledger builds on macOS and Linux without special setup
* [ ] A user can create, search, and export journal entries
* [ ] Data is encrypted at rest
* [ ] The CLI feels natural

### Phase 1.0 is successful if:

* [ ] A format specification exists
* [ ] Migration tooling exists
* [ ] The project can make stability guarantees

---

## 16. What We're NOT Building (Yet)

* Mobile apps
* Web interface
* Cloud sync
* Team/shared ledgers
* Plugin system
* AI integration

These are explicitly out of scope to maintain focus.
