# RFC-004: Data Model & Schema

**Status:** Draft (Revised)
**Audience:** Core maintainers, contributors
**Applies to:** Jot v0.1+

---

## 1. Goals

The data model must:

* Support multiple storage backends (see RFC-001)
* Use **globally unique identifiers** (UUIDs) for all entities
* Be **append-only** by default (no in-place mutation)
* Include **device metadata** for future conflict resolution
* Enable **fast queries and full-text search**
* Allow **schema evolution without data loss**

---

## 2. Core Entities

Jot stores four kinds of things:

1. **Entry Types** — schema definitions (e.g., `journal`, `weight`)
2. **Templates** — reusable defaults for creating entries
3. **Entries** — instances of entry types (the actual data)
4. **Metadata** — global settings, FTS indexes, migration state

### Design Principle

> **All identifiers are UUIDs. All writes are append-only. Nothing is implicit.**

This ensures:
* Entries can be created on any device without ID collision
* Merge conflicts are resolvable
* Data history is preserved

---

## 3. Entity: Entry Type

An entry type defines the schema for a category of entries.

### 3.1 Entry Type Record

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Globally unique identifier |
| `name` | string | User-facing name (e.g., `weight`) |
| `created_at` | datetime | When this type was created |
| `device_id` | UUID | Device that created this type |

### 3.2 Entry Type Version Record

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Globally unique identifier |
| `entry_type_id` | UUID | Reference to entry type |
| `version` | integer | Version number (1, 2, 3...) |
| `schema_json` | JSON | Field definitions |
| `created_at` | datetime | When this version was created |
| `active` | boolean | Whether this is the current version |

### 3.3 Schema JSON Format

```json
{
  "name": "weight",
  "version": 1,
  "fields": [
    {
      "name": "weight",
      "type": "number",
      "required": true,
      "order": 1
    },
    {
      "name": "date",
      "type": "date",
      "default": "today",
      "order": 2
    }
  ]
}
```

Optional schema references:

* `default_composition_id` (UUID, references Composition)

---

## 4. Entity: Template

Templates are reusable defaults for creating entries. They live **inside the encrypted jot**
so templates can be shared across machines as long as the jot file is shared.

### 4.1 Template Record

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Globally unique identifier |
| `name` | string | User-facing name (unique within jot) |
| `entry_type_id` | UUID | Entry type this template applies to |
| `created_at` | datetime | When this template was created |
| `device_id` | UUID | Device that created this template |
| `description` | string? | Optional description |

### 4.2 Template Version Record

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Globally unique identifier |
| `template_id` | UUID | Reference to template |
| `version` | integer | Version number (1, 2, 3...) |
| `template_json` | JSON | Template defaults + UX hints |
| `created_at` | datetime | When this version was created |
| `active` | boolean | Whether this is the current version |

### 4.3 Template JSON Format

```json
{
  "defaults": { "car": "civic", "octane": "regular" },
  "default_tags": ["car", "fuel"],
  "default_compositions": ["3b0c9b72-3a9d-4ad6-8a70-2c52a6622f3a"],
  "prompt_overrides": {
    "car": "Which car did you fill?"
  }
}
```

Templates are append-only. Updating a template creates a new version and marks it active.

---

## 5. Entity: Entry

An entry is an instance of an entry type.

### 5.1 Entry Record

| Field | Type | Description |
|-------|------|-------------|
| `id` | UUID | Globally unique identifier |
| `entry_type_id` | UUID | Reference to entry type |
| `schema_version` | integer | Schema version used |
| `data_json` | JSON | Field values |
| `tags_json` | JSON | Array of tag strings |
| `created_at` | datetime | When entry was created (UTC) |
| `device_id` | UUID | Device that created this entry |
| `supersedes` | UUID? | If this is a revision, the entry it replaces |

### 5.2 Data JSON Format

```json
{
  "weight": 175.5,
  "date": "2026-01-07"
}
```

For journal entries:

```json
{
  "body": "Today was a good day..."
}
```

### 5.3 Tags JSON Format

```json
["health", "fitness", "daily"]
```

---

## 6. UUID Strategy

### 6.1 Why UUIDs?

* **No ID collision** across devices
* **Mergeable** — entries from different devices don't conflict on IDs
* **Stable references** — IDs never change

### 6.2 UUID Version

Use **UUIDv7** (time-ordered) where available, or **UUIDv4** (random) as fallback.

UUIDv7 benefits:
* Naturally sorted by creation time
* Better index locality
* Debuggable (timestamp visible)

### 6.3 Device ID

Each Jot installation generates a stable device ID on first run:

```
~/.config/jot/device_id
```

This ID is included in all created entries and schemas.

---

## 7. Append-Only Model

### 7.1 No In-Place Updates

Entries are **never modified in place**. Instead:

* **Revisions** create a new entry with `supersedes` pointing to the original
* **Deletes** are soft (tombstone flag, Phase 1.0+)

### 7.2 Benefits

* Full audit trail
* Safe for conflict resolution
* Recoverable from mistakes

### 7.3 Viewing Revisions

```bash
jot show <id> --history
```

Shows:
* Original entry
* All revisions
* Timestamps and devices

---

## 8. Timestamps & Timezones

### 8.1 Storage Format

All timestamps stored as:

* **ISO-8601 strings**
* **UTC timezone**

Example:

```
2026-01-07T14:32:11Z
```

### 8.2 User Timezone

User timezone preference is stored in metadata. Display commands convert to local time.

---

## 9. Tags

### 9.1 Storage

Tags are stored as a JSON array on each entry:

```json
["health", "morning", "important"]
```

### 9.2 Normalization

Tags are:
* Lowercased
* Trimmed
* Deduplicated

### 9.3 Querying

For the SQL-based backends, tags can be queried via:
* JSON functions
* Generated columns
* Dedicated index

---

## 10. Full-Text Search (FTS)

### 10.1 What Gets Indexed

The FTS index includes:

| Source | Indexed? | Notes |
|--------|----------|-------|
| `text` type fields | Yes | Journal body, notes, etc. |
| `string` type fields | Yes | Task names, short text |
| `number` type fields | No | Not useful for text search |
| `date` type fields | No | Use structured queries instead |
| `boolean` type fields | No | Use structured queries |
| Field names | No | Only values are indexed |
| Tags | Yes | Searchable as text |
| Entry type name | Yes | Can search "in weight entries" |

### 10.2 Index Content Generation

For each entry, generate a search document:

```
<entry_type_name> <tag1> <tag2> ... <text_field_1> <string_field_1> ...
```

Example for a journal entry:

```
journal morning health Today was a good day. I went for a run and...
```

Example for a weight entry:

```
weight daily 175.5
```

Wait — should numbers be indexed? Let's be explicit:

* Numbers are included in the search document as strings
* This allows `jot search 175` to find weight entries
* But structured queries (`--where "weight > 170"`) are preferred

### 10.3 FTS Synchronization

On entry insert:
1. Extract all text/string fields from `data_json`
2. Add entry type name
3. Add all tags
4. Concatenate into search document
5. Insert into FTS index

### 10.4 Search Ranking

Results ordered by:
1. FTS relevance score
2. Recency (tie-breaker)

---

## 11. SQL Schema (For SQL Backends)

This is the reference schema for SQLite/SQLCipher backends.

### 11.1 Metadata Table

```sql
CREATE TABLE meta (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);
```

Initial values:
* `jot_version` — app version that created this jot
* `schema_version` — database schema version (for migrations)
* `created_at` — when jot was created
* `device_id` — device that created this jot

### 11.2 Entry Types Table

```sql
CREATE TABLE entry_types (
    id TEXT PRIMARY KEY,           -- UUID
    name TEXT NOT NULL UNIQUE,
    created_at TEXT NOT NULL,      -- ISO-8601
    device_id TEXT NOT NULL        -- UUID
);
```

### 11.3 Entry Type Versions Table

```sql
CREATE TABLE entry_type_versions (
    id TEXT PRIMARY KEY,           -- UUID
    entry_type_id TEXT NOT NULL,   -- UUID
    version INTEGER NOT NULL,
    schema_json TEXT NOT NULL,
    created_at TEXT NOT NULL,      -- ISO-8601
    active INTEGER NOT NULL DEFAULT 1,

    UNIQUE(entry_type_id, version),
    FOREIGN KEY(entry_type_id) REFERENCES entry_types(id)
);
```

### 11.4 Entries Table

```sql
CREATE TABLE entries (
    id TEXT PRIMARY KEY,           -- UUID
    entry_type_id TEXT NOT NULL,   -- UUID
    schema_version INTEGER NOT NULL,
    data_json TEXT NOT NULL,
    tags_json TEXT,
    created_at TEXT NOT NULL,      -- ISO-8601
    device_id TEXT NOT NULL,       -- UUID
    supersedes TEXT,               -- UUID of replaced entry

    FOREIGN KEY(entry_type_id) REFERENCES entry_types(id)
);
```

### 11.5 FTS Index

```sql
CREATE VIRTUAL TABLE entries_fts USING fts5(
    entry_id UNINDEXED,
    content,
    tokenize = 'porter'
);
```

### 11.6 Indexes

```sql
CREATE INDEX idx_entries_type_date
    ON entries(entry_type_id, created_at);

CREATE INDEX idx_entries_created_at
    ON entries(created_at);

CREATE INDEX idx_entries_supersedes
    ON entries(supersedes) WHERE supersedes IS NOT NULL;
```

---

## 12. Migrations

### 12.1 Database Schema Migrations

Tracked via `meta.schema_version` (or `PRAGMA user_version` for SQLite).

Rules:
* Each migration is explicit and idempotent
* Jot refuses to open newer schema versions
* Upgrade path is always forward

### 12.2 Entry Schema Migrations

Entry data is **never automatically migrated**. Old entries remain valid under their schema version.

Future tooling (Phase 1.0+) may support:
* Batch migration with user consent
* Field rename/transform operations

---

## 13. Integrity Guarantees

### 13.1 Write-Time Validation

* No entry exists without a valid entry type
* No entry type version exists without an entry type
* No FTS row exists without a backing entry
* All UUIDs are validated before storage

### 13.2 Consistency Checks

`jot check` runs:
* Schema integrity verification
* FTS index sync check
* Orphan detection
* UUID format validation

---

## 14. Backend-Agnostic Considerations

While this RFC shows SQL schemas, the logical model works for other backends.

### 14.1 Source of Truth Invariant

For any backend architecture:

> **Encrypted data is the source of truth. Indexes are caches.**

This means:
* Indexes can always be rebuilt from encrypted entries
* Recovery procedures never rely on index state
* Tests must verify index-rebuild correctness
* User-facing commands never expose index internals
* If index and encrypted data disagree, encrypted data wins

This invariant must hold regardless of backend implementation.

### 14.2 GPG + Files Backend

```
jot/
├── meta.json.gpg
├── types/
│   ├── journal.json.gpg
│   └── weight.json.gpg
├── entries/
│   ├── 2026-01-07-abc123.json.gpg
│   └── ...
└── index.db              # cache, rebuilt on unlock
```

### 14.3 Mapping

| Logical Entity | SQL | GPG+Files |
|----------------|-----|-----------|
| Entry Type | Row in `entry_types` | `types/<name>.json.gpg` |
| Template | Row in `templates` | `templates/<name>.json.gpg` |
| Entry | Row in `entries` | `entries/<date>-<uuid>.json.gpg` |
| FTS Index | `entries_fts` table | Rebuilt from entries on unlock |

---

## 15. Phase Rollout

| Feature | Phase 0.1 | Phase 0.2 | Phase 1.0 |
|---------|-----------|-----------|-----------|
| UUID-based IDs | Yes | Yes | Yes |
| Device ID tracking | Yes | Yes | Yes |
| Append-only entries | Yes | Yes | Yes |
| Built-in `journal` type | Yes | Yes | Yes |
| User-defined types | No | Yes | Yes |
| FTS search | Yes | Yes | Yes |
| Entry revisions | No | Limited | Full |
| Soft delete | No | No | Yes |
| Compositions | No | Yes | Yes |
| Templates | No | Yes | Yes |

---

## 16. Templates (Phase 0.2+)

Templates provide reusable defaults for entry creation. They are stored inside the jot
so they can be shared across machines.

Data model additions for Phase 0.2:

* `templates` table (id, name, entry_type_id, description, created_at, device_id)
* `template_versions` table (template_id, version, template_json, created_at, active)
* `entry_type_templates` table (entry_type_id, template_id, active)

Template JSON includes:

* Default field values
* Default tags
* Default compositions (optional)
* Prompt overrides (optional)

Best-practice constraints:

* One active mapping per entry type.
* New defaults deactivate prior mappings.

Example SQL (SQLite):

```sql
CREATE TABLE entry_type_templates (
    entry_type_id TEXT NOT NULL,
    template_id TEXT NOT NULL,
    active INTEGER NOT NULL DEFAULT 1,

    PRIMARY KEY (entry_type_id, template_id),
    FOREIGN KEY (entry_type_id) REFERENCES entry_types(id),
    FOREIGN KEY (template_id) REFERENCES templates(id)
);

CREATE UNIQUE INDEX entry_type_templates_active
ON entry_type_templates (entry_type_id)
WHERE active = 1;
```

Migration note:

- Use a partial unique index (`active = 1`) so historical mappings remain stored while
  enforcing a single active default.

---

## 17. Compositions (Phase 0.2+)

Compositions provide semantic grouping of entries across types. See **RFC-006** for full specification.

Data model additions for Phase 0.2:

* `compositions` table (id, name, description, metadata)
* `entry_compositions` join table (many-to-many)
* Optional `default_composition_id` field in entry type schemas

---

## 18. Open Questions (Deferred)

* Normalized tags table (performance at scale)
* Attachment/blob storage
* Multi-jot linking
* Compression for large text fields

---

## 19. Why This Design Works

This model:

* Supports eventual multi-device use (UUIDs + device IDs)
* Preserves complete history (append-only)
* Works with multiple storage backends
* Enables fast queries and search
* Scales to years of personal data
* Treats your journal like a real database, not a pile of notes
